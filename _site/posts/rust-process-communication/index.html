<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width-device-width, initial-scale=1.0">
    <title>Dealing with long-lived child processes in Rust: Part 1</title>
    <meta name="description" content="Notes on dealing with child processes that I found a bit tricky or not documented well.">
    <link rel="stylesheet" href="/css/typography.css">
    <link rel="stylesheet" href="/css/style.css">
  </head>
  <body>
    <header class="blog-header">
      <h3 class="home"><a class="title" href="/">nikbrendler.com</a></h3>
      <nav class="pages">
        <a href="/projects/">projects</a>
      </nav>
      <nav class="social">
        <a href="https://github.com/nbrendler">
          <img src="/img/github.png" />
        </a>
        <a href="https://twitter.com/NikBrendler">
          <img src="/img/twitter.png" />
        </a>
      </nav>
    </header>
    <main>
    <h1>Dealing with long-lived child processes in Rust: Part 1</h1>

<p>I've been writing a small program in Rust to fill a need I have with my current
setup (a terminal-based chat client for Keybase). It's my first foray into some
areas of Rust like async and spawning child processes, and also my first
terminal UI.</p>
<p>One requirement of the program was to run a background process (the chat
listener) that would communicate back to the main process when it received an
event (a new chat message). Most child processes in my experience are usually a
one-and-done affair. Run it, collect the output and be on your merry way. Here I
had a need to keep it running in the background, send the output asynchronously
to my UI thread, and make sure to clean up the process when my program exits.</p>
<p>This all ended up being a bit tricky for an unexperienced Rust programmer like
me, so I'm documenting a few of the challenges and approaches I tried to solve
it, along with what I ended up with.</p>
<p>For this Part 1, I'll talk about different ways to communicate with the
processes. Part 2 will cover signal handling to clean up the processes when the
main process is interrupted.</p>
<h3>Async communication with processes</h3>
<p>Problem: After spawning a child process, how should it communicate back to the
main process?</p>
<p>The Rust documentation for the
<a href="https://doc.rust-lang.org/std/process/index.html">process</a> module is all
blocking and waiting for child output, but a quick search gives you a few
options: callbacks, channels, or tokio (streams and async/await).</p>
<p>For a simple cases, callbacks should be the first thing you reach for.  Here's
an example where I grab a line from stdout and send it back with my callback.</p>
<pre><code class="language-rust">use std::io::{BufRead, BufReader};
use std::process::{Command, Stdio};
use std::thread;
use std::thread::sleep;
use std::time::Duration;

fn start_listener&lt;T: 'static + Send + Fn(&amp;str)&gt;(cb: T) {
    let child = Command::new(&quot;ping&quot;)
        .arg(&quot;google.com&quot;)
        .stdout(Stdio::piped())
        .spawn()
        .expect(&quot;Failed to start ping process&quot;);

    println!(&quot;Started process: {}&quot;, child.id());

    thread::spawn(move || {
        let mut f = BufReader::new(child.stdout.unwrap());
        loop {
            let mut buf = String::new();
            match f.read_line(&amp;mut buf) {
                Ok(_) =&gt; {
                    cb(buf.as_str());
                }
                Err(e) =&gt; println!(&quot;an error!: {:?}&quot;, e),
            }
        }
    });
}

fn main() {
    start_listener(|s| {
        println!(&quot;Got this back: {}&quot;, s);
    });

    sleep(Duration::from_secs(5));
    println!(&quot;Done!&quot;);
}
</code></pre>
<p>This is a bit contrived, but there's still a few things to unwrap.</p>
<ul>
<li>We sleep for five seconds to let <code>ping</code> give us something to look at, but in
a real program we could be doing other things -- in my case, running the
rendering loop for the terminal UI.</li>
<li>We're not doing anything interesting in the callback. Just printing is a bit
of a cop-out, because you won't run afoul of any ownership constraints
imposed by Rust. Note how the callback is required to have a static
lifetime (because the thread could have a static lifetime), so the
compiler will likely yell at us if we tried to do anything interesting.</li>
<li>We're not doing any cleanup of the <code>Child</code> process, so the <code>ping</code> command
will continue to run forever until killed. I believe this is handled by
Cargo in simple cases like this, but we need to handle it ourselves as
Cargo won't always be running the binary for us.</li>
</ul>
<p>Here's the same thing, but now we're using a channel instead of a callback.</p>
<pre><code class="language-rust">use std::io::{BufRead, BufReader};
use std::process::{Command, Stdio};
use std::sync::mpsc::{channel, Sender, TryRecvError};
use std::thread;
use std::thread::sleep;
use std::time::Duration;

fn start_listener(sender: Sender&lt;String&gt;) {
    let child = Command::new(&quot;ping&quot;)
        .arg(&quot;google.com&quot;)
        .stdout(Stdio::piped())
        .spawn()
        .expect(&quot;Failed to start ping process&quot;);

    println!(&quot;Started process: {}&quot;, child.id());

    thread::spawn(move || {
        let mut f = BufReader::new(child.stdout.unwrap());
        loop {
            let mut buf = String::new();
            match f.read_line(&amp;mut buf) {
                Ok(_) =&gt; {
                    sender.send(buf).unwrap();
                }
                Err(e) =&gt; println!(&quot;an error!: {:?}&quot;, e),
            }
        }
    });
}

fn main() {
    let (tx, rx) = channel();
    start_listener(tx);

    loop {
        match rx.try_recv() {
            Ok(line) =&gt; {
                println!(&quot;Got this back: {}&quot;, line);
            }
            Err(TryRecvError::Empty) =&gt; {
                sleep(Duration::from_secs(1));
                continue;
            }
            Err(e) =&gt; {
                println!(&quot;Error: {:?}&quot;, e);
                break;
            }
        }
        }

    println!(&quot;Done!&quot;);
}
</code></pre>
<p>Note that this will run forever until you hit Ctrl-C, so our 'Done!' will never
be reached. It is possible to use a timeout to get the same behavior as above,
but I haven't implemented it here.</p>
<p>This is what I ended up settling on for my program, as it gives a little bit
more flexibility. The channel parts can be very cheaply cloned and stored in
other structs if desired. The <a href="https://crates.io/crates/crossbeam">crossbeam</a>
crate, which is a mostly drop-in replacement for the message-based tools
included in the standard library, has a <code>select!</code> macro that nicely encapsulates
the loop logic, and is purportedly much faster.</p>
<h3>Bidirectional communication</h3>
<p>Problem: What if I want to be able to send more information to the process via
stdin, while still getting information back from it?</p>
<p>While you could accomplish this using callbacks, this is more of a textbook case
for using channels. Below I've modified our example to work as more of an echo
server. We send it input that will be echoed back after a delay. Note that we
now need two channels, one to send information to the child, and one for the
child to send back to us.</p>
<pre><code class="language-rust">use std::io::{BufRead, BufReader, Write};
use std::process::{Command, Stdio};
use std::sync::mpsc::{channel, Receiver, Sender, TryRecvError};
use std::sync::Mutex;

use std::thread;
use std::thread::sleep;
use std::time::Duration;

fn start_process(sender: Sender&lt;String&gt;, receiver: Receiver&lt;String&gt;) {
    let child = Command::new(&quot;cat&quot;)
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .expect(&quot;Failed to start process&quot;);

    println!(&quot;Started process: {}&quot;, child.id());

    thread::spawn(move || {
        let mut f = BufReader::new(child.stdout.unwrap());
        let mut stdin = child.stdin.unwrap();
        loop {
            match receiver.try_recv() {
                Ok(line) =&gt; {
                    stdin.write_all(line.as_bytes()).unwrap();
                }
                Err(TryRecvError::Empty) =&gt; {
                    sleep(Duration::from_secs(1));
                    continue;
                }
                Err(e) =&gt; {
                    println!(&quot;Error: {:?}&quot;, e);
                }
            }
            let mut buf = String::new();
            match f.read_line(&amp;mut buf) {
                Ok(_) =&gt; {
                    sender.send(buf).unwrap();
                    continue;
                }
                Err(e) =&gt; {
                    println!(&quot;an error!: {:?}&quot;, e);
                    break;
                }
            }
        }
    });
}

fn start_command_thread(mutex: Mutex&lt;Sender&lt;String&gt;&gt;) {
    thread::spawn(move || {
        let sender = mutex.lock().unwrap();
        sleep(Duration::from_secs(3));
        sender
            .send(String::from(&quot;Command from the thread\n&quot;))
            .unwrap();
    });
}

fn main() {
    let (tx1, rx1) = channel();
    let (tx2, rx2) = channel();

    start_process(tx1, rx2);

    tx2.send(String::from(&quot;Command 1\n&quot;)).unwrap();
    start_command_thread(Mutex::new(tx2));

    loop {
        match rx1.try_recv() {
            Ok(line) =&gt; {
                println!(&quot;Got this back: {}&quot;, line);
            }
            Err(TryRecvError::Empty) =&gt; {
                sleep(Duration::from_secs(1));
                continue;
            }
            Err(e) =&gt; {
                println!(&quot;Error: {:?}&quot;, e);
            }
        }
    }

    println!(&quot;Done!&quot;);
}
</code></pre>
<p>Note that we have to use a mutex because <code>Send</code> is not implemented for the
sender objects. This is also done by crossbeam, but I wanted to avoid extra
crates for the example. I'm also cloning the sender somewhat unnecessarily to
avoid it being dropped (and closing the channel) when the command thread
finishes.</p>
<p>This is mostly there now, minus one problem. If you grep for <code>cat</code> processes,
you probably have a few zombified processes lingering around. In part 2 we'll
discuss signal handling and the cleanup.</p>


<hr>
<ul><li>Next: <a href="/rust-process-communication-part-2">Dealing with long-lived child processes in Rust: Part 2</a></li><li>Previous: <a href="/posts/kernel-status-script/">Kernel status script</a></li>
</ul>

    </main>
  </body>
</html>
